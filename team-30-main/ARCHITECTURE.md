![arkitekturskisse_2 0_endelig drawio](https://media.github.uio.no/user/8394/files/94332fe1-cd7b-4e86-9fa4-e116811dcaef)


Arkitekturen til applikasjonen består av fire forskjellige skjermer. Hjemskjermen “HomeScreen” er hovedskjermen til applikasjonen. Ved bruk av to-veisflyt, spør hjemskjermen om data fra viewmodelen “HomeScreenViewModel” og visualiserer dette på skjermen. Viewmodelen spør om data fra både “MetAlertRepository” og “LocationForecastRepository” og holder på det i ulike states. Repositoriene henter data fra datasourcene ved hjelp av fetching-funksjoner. Datasourcene kaller på API-ene “MetAlert” og “LocationForecast” fra MET og får tilbake data i JSON format. Nesten hele arkitekturen vår er basert på toveisflyt.

“PlacesSearchScreen” er skjermen som blir brukt for søking og endring av lokasjonen til applikasjonen. API-et som blir benyttes her er “Places” fra Google. Skjermen henter informasjon på samme måte som de andre API-ene, men ved bruk av andre fetching funksjoner. “ClockScreen” og “HomeScreen” blir tilsendt koordinater via navController fra “PlacesSearchScreen” slik at lokasjonen blir oppdatert i skjermene.

“WeatherDetailsScreen” og “ClockScreen” benytter seg av viewmodelen “ClockScreenViewModel”. Denne viewmodelen er enkelt forklart en mindre versjon av “HomeScreenViewModel”. De har mye lik funksjonalitet. I etterkant innså vi at det hadde vært bedre med en egendefinert superklasse “ViewModel”, hvor vi kunne holdt på de “statene” som var like. Viewmodelen henter data fra domenelageret vårt fra klassen “GroupTimeListByDataUseCase”, som innholder funksjoner som kun er nyttig for “ClockScreenViewModel”. Klassen henter data fra “GoogleTimeZone” og “LocationForecast” API-ene på samme måte som vi henter data fra alle API-ene. 

“LocationInfoRepository” er et datalager vi har for funksjoner vi mener er nyttige. Dataen hentes fra både “HomeScreenViewModel” go ClockScreenViewModel” og inneholder funksjoner som hjelper oss med henting av GPS-lokasjon, henting av områdetekst og funksjonalitet som beregner hvordan temperaturen føles ut som. Disse metodene henter ikke data direkte fra API-er, men benytter seg av blant annet GPS-lokasjon på enheten og noe data som Viewmodelene holder på. Funksjonen getCurrentAreaName() bruker geocoder som returnerer informasjon om adresse basert på koordinater som den får. 

Vi har forsøkt å holde lav kobling og høy kohesjon, men vi vet at det er noen steder i både arkitekturen og sluttproduktet hvor vi ikke har fulgt prinsippene fullt ut. I figuren har vi egne klasser for funksjonalitet som håndterer presentasjon (View) som er skilt fra selve forretningslogikken (ViewModel) og dataen (Model). Ved å følge MVVM har ikke dette vært et så stort problem, men det er et sted hvor vi ikke følger denne strukturen. I “PlacesSearchScreen”, sendes det koordinater via navController til både “HomeScreen” og “ClockScreen”. Her forstår vi at vi bryter i prinsippene i MVVM. Siden et View sender koordinater til andre Views. Vi blander presentasjonslogikken og forretningslogikken sammen, selv om disse strengt tatt skal holdes adskilt. Vi mener at vi har fått til lav kobling på en god måte. Endringer i et objekt vil ikke føre til at endringer må gjennomføres i andre objekter. 

 Når det kommer til standardene til UDF, mener vi at dette er noe vi kunne fulgt bedre. Dette er basert på at selv om vi lagde egendefinerte funksjoner, var vi dårlig på å gjenbruke dem. Vi kunne, sett i etterkant, laget en super-viewmodel og holdt på informasjonen som var relevant for alle viewmodelene. Da kunne vi ha gjenbrukt enda flere funksjoner. 

Vi valgte API-nivå 34. Dette valget er basert på det som hadde blitt demonstrert i både forelesninger og gruppetimer. Dette var også API-nivået som vi hadde arbeidet med i de to første obligatoriske oppgavene i emnet. Da vi først satte opp Android Studio, så var det også det anbefalte API-nivået å velge. Applikasjonen vår kjører helt ned til API-nivå 24, men under utvikling og testing har vi hovedsakelig kjørt den på nivå 34. 

